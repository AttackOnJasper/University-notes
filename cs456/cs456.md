# CS 456 2018 Spring
 
## Course Outline
- Overall Picture of Internetworking
- Application Layer
- Transport Layer
- Network Layer (will be seperated into 4a and 4b)
- Data Link Layer & Local Area Networks

## 1.1 What is Internet (2018-05-01)
### Elements (nuts and bolts) view 
- a global system of interconnected computer networks that use the Internet protocol suite (TCP/IP) to link devices worldwide.
    - billions of connected devices (will go up to 25 bn in 2020)
- Analogy between data transfer in internet & product shipping
- **Network edge** consumer of the network (host, end systems)
- ISP: internet service provider
- **Hosts** end systems (connected computing devices, client, server); sends packets of data
- Links
- **Packet** small pieces of data transferred in network
- **Packet Switch** make the routing decision about which path to choose for packets to reach the destination & forward packets (imagine transfer as a pipe, there is a bandwidth, or limit - constraint of the wire)
    - Why there is bandwidth in wireless network? There are many end systems; each only get a frequency band of the network
    - Difference between router & switch
        - switch: located at local network; part of access network, which is part of the network edge
        - router: located at core of network (make routing decision based on IP addresses)
- **Protocols** control sending / receiving of messages
- **Internet standard**
    - protocols will be reviewed by standards before released
    - RFC (Request for comments)
    - IETF (Internet Engineering Task Force)

### **Service view**: Infrastructure (treat as blackbox) that provides services + API to applications
- Client & Server
- Why distributed? processing power limitation + client/server pattern

### Socket Interface (analogy to post office during sending letters process)
- Provide the way to communicate between client & server
- Developers should follow the guidelines to communicate between client & server
- Developers can choose the type of 'service' (e.g. guarantee delivery of message, speed of delivery)

### Protocols
- define format, order of messages sent and received among network entities, and actions taken on message transmission or receipt (make sure everyone can understand each other) 
- e.g. TCP, IP, HTTP
    - HTTP clients: e.g. browser

## 1.2 Network edge (2018-05-03)
End systems (hosts, data center), access networks, links

### Access networks (bandwidth, shared / dedicated)
- Connect end systems to edge router
    - e.g. cellular network, residential access network, institutional access network
- DSL (digital subscriber line): connect network using a phone line (data -> internet; voice -> phone)
    - dedicated access
    - **frequency division multiplexing**: different channels transmitted in different frequency bands
    - DSL modem: convert signal from end systems to analog signals; connect 1 end to router + wireless access, the other end to splitter
    - DSLAM (DSL access multiplexier): in central office; split the data and send data to either telephone network or ISP
    - 1 wire, 3 frequencies (telephone, internet upstream, and internet downstream)
    - Splitter: split data and transfer to end system (computer, telephone)
    - Central office decides transmission rate of internet
- Cable: from home to ISP router
    - data, TV transmitted at different frequencies over shared cable
    - data is broadcasted
    - CMTS: cable modem termination system
    - not dedicated
        - collision in upstream
        - no collision in downstream since CMTS is the only provider
- Ethernet
    - **ethernet switch** in network edge; connected to end systems including computers, server, wireless access
- Wireless
    - collision in both upstream and downstream
    - devices -> base station -> router -> ISP
    - e.g. Wifi, wide area wireless access: 3G, 4G, LTE

### Physical media
- twisted pair
- coaxial cable
- fiber optic cable: light pulse, high speed, low error rate
- radio (unguided)
    - electromagnetic spectrum
    - e.g. LAN, cellular, satellite, terrestrial microwave

## 1.3 Network core: routers, network of networks (2018-05-08)
- collection of interconnected routers
- key network core functions:
    - **routing**: determines source destination route taken by packets
    - **forwarding**: move packets from router’s input to appropriate router output
- **Packet Switching** hosts break application-layer messages into packets & forward packets from one router to next
    - each packet transmitted at full link capacity (i.e. as fast (greedy) as possible)
    - **store and forward** entire packet must arrive at router before it can be transmitted on next link
        - Why? Router needs to check the integrity of the message and needs info to determine the output link of the message
    - **Transmission rate** bits/sec, also known as link capacity, link bandwidth
    - **Transmission delay** time to transmit packet from router to link
        - $$ \frac{NL}{R} $$ where L - bits, R - transmission rate, N - # of links
        - for Pth packet going through n links, delay is $$ \frac{(N + P - 1)*L}{R} $$
    - Internet is a packet-switched network
- **Circuit Switching** 
    - end-end resources allocated to, reserved for “call” between source & dest (dedicated resource)
    - dedicated links
    - FDM vs TDM (freq. vs time frame) affects transmission rate
- Packet switching vs circuit switching
    - packet switching allows more users to use network, but may have congestion (packet delay & loss)
    - circuit switching provides dedicated access
- Network structure
    - Global ISP, content provider
    - IXP (support 1-to-many or many-to-many)
    - Regional ISP
    - Access network

## 1.4 Delay, Loss, and throughput in networks (2018-05-10)
- **Nodal delay = nodal processing + queueing delay + transmission delay + propagation delay**
- Nodal processing: check integrity of message and determine output link (usually < msec)
- Queueing delay (traffic intensity): $$\frac{La}{R}$$ where $$L$$ is packet length, $$a$$ is packet arrival rate, $$R$$ is link bandwidth
    - if n packets, average delay = $$ (n-1)L/2R $$
    - if $$\frac{La}{R} > 1$$, then more work coming than serviced; infinite average delay
- Propagation delay: distance / speed
- Traceroute program
- Throughput: rate at which bits transferred between sender and receiver
    - instantaneous / average
    - throughput is bounded by bottleneck link



## 1.5 Protocol Layers & Security
### Protocol Layers
- each layer implements a different service
    - rely on the services other layers provided
- why layering?
    - allows identification of complex system
    - modularization (maintenance)
- Application layer: supporting network applications
    - e.g. HTTP
- Presentation: allow applications to interpret meaning of data
- Session: synchronization, checkpointing
- Transport layer: data transfer between processes
    - e.g. TCP provides congestion + flow control
- Network layer: routing of datagrams from source to destination
    - e.g. IP, routing protocol
- Link layer
- Physical layer

### data naming for each layer
- message
- segment
- datagram
- frame

## 1.6 Security
- virus: need execution
- worm: passive
- Denial of Service: overwhelm traffic
- Packet sniffing: record packets in shared network
- IP spoofing: send packet with false source address

## 2.1 Application Layer Overview (2018-05-17)
### Application architectures (on end systems; not network core)
- Client-server
    - server: always-on host, permenant IP address
    - client: communicate with servers
- P2P
    - arbitrary end systems directly communicate
    - **self scalability** new peers bring new service capacity and new service demands
    - no permenant IP address

### Processes communicating
- **Process** program running within a host
    - same host: inter-process communication
    - different hosts: exchanging messages
- **Client process** process that initiates communication
- **Server process** process that waits to be contacted
- P2P architecture has client process + server process

### Sockets (act as door)
- sending process: push message out of door; picked up by transport layer
- the other process receives the message at door
- Addressing processes: IP address
    - to receive messages, process must have identifier, which includes both IP address and port numbers

### Application-layer protocol
- defines  
    - type of messages exchanged (e.g. request, response)
    - message syntax: fields
    - message semantics: meaning of each fields
    - rules for when and how processes send and respond to messages
- application service requirments: reliability, bandwidth, delay

### Transport services
- Transportation requirements for apps
    - data integrity
    - timing
    - throughput
    - security
- TCP: reliable, flow control (won't overwhelm receiver), congestion control, connection-oriented (need setup)
    - but no timing, minimum throughput guarantee, security
- UDP: connectionless, fast (no congestion control), small header size
- SSL (encrypted TCP): app layer but talks to TCP

## 2.2 Web and HTTP (2018-05-24)
### HTTP
- client/server model
- uses TCP, default port 80
- stateless: maintain no information about past client requests
- non-persistent vs persistent
    - **RTT** time for a small packet to travel from client to server and back
- request / response message format
    - method types: GET POST PUT DELETE
    - status code: 200, 301, 40x, 500

### HTTP 2
- server PUSH: push resources to clients
    - e.g. send 1 request to get html, server pushes other images
- binary framing: header frame + data frame
- header compression
- multiplexing requests: break down, interleave in parallel, and reassemble
    - fixes head-of-line blocking (packets held up by the first packet)

### Cookie
- 4 components: request, response, local file, server db
- Functionality:
    - authorization
    - user session state

### Web caches (proxy)
- sends all HTTP requests to cache first
- installed by ISP
- Conditional GET (to update cache if needed)

## 2.3 Electronic mail (2018-05-29)
### 3 components 
- user agents (e.g. mail app, outlook)
- mail servers
    - outgoing queue, user mailbox
    - both a client and a server
- SMTP (simple mail transfer protocol - app layer)
    - send mails among mail servers (direct transfer; 3 phases) and store mails to mailbox
    - uses TCP, default port 25
    - persistent connection (maintain states)
    - message in 7-bit ASCII (including image)
    - MIME (Multipurpose Internet Mail Extensions): reconstruct images from 7-bit ASCII

### Process of sending mails
User agent -> mail server -> TCP connection with destination mail server -> check sender and recipient -> send mail to destination server -> mail access protocol -> destination user agent

### Mail access protocols: retrieval from mail server
- POP (Post office protocol)
    - Authroization phase (user, pass) + transaction phase (list, retr)
    - Download message then read / delete
    - Stateless
- IMAP (Internet Mail Access Protocol)
    - Keep all messages in server
    - Keep user state across sessions
- HTTP (e.g. gmail)

## 2.4 DNS (Domain name system) (2018-06-05)
### Components
- Distributed db storing resource records including IP address and name mappings
    - Hierarchy of name servers
        - Root name servers
        - TLD (top level doamin) name servers (e.g. .com DNS server)
            - maintained by 3-rd party companies
        - Authoritative (company) DNS (e.g. amazon.com DNS server)
    - Record format: (name, value, type, ttl)
    - Record types
        - A: hostname (machine name) -> IP
        - NS: domain (e.g. amazon.com) -> hostname
        - CNAME: alias (e.g. www.abc.com) -> hostname
        - MX: mail server alias -> hostname
    - To insert a record
        - register name xxx.com at DNS registrar
        - Cretae a type A record and a type NS record
- Application-layer protocol
    - query IP address by name and vice versa
    - message format same for request and response
    - fields: Id (16 bit number), flag (query or reply), questions, answer RRs, authority RRs (authoritative server records), additional RRs
    - stateless
- Local DNS name server (proxy, cache)
    - DNS name resolution: iterated query vs. recursive query
    - usually cache TLD server records (so does not access root server very often)
    - TTL decides when to timeout a cache
    - cache may be out-of-date (need update mechanism)

### Functionality
- Hostname, IP address translation
- Aliasing
- Load distribution

### Attacking DNS
- DDoS attack: bombard root server or TLD
- Redirect attacks: intercept queries

## 2.5 P2P applications (2018-06-07)
- End systems directly communicate
- Dynamic IP addresses; not always on-host
- File distribution example: BitTorrent
    - **swarm** group of peers exchanging chunks of a file
    - **tracker** tracks peers in swarm
    - **chunk** small pieces of the distributed file
    - while downloading, peer uploads chunks to others
    - request chunks: request from the peers that have the most different chunks
    - send chunks
        - send to 4 peers that are sending chunks to me at highest rates; re-evaluate every 10s
        - randomly select another peer every 30s

## 2.6 Video streaming and CDNs (2018-06-07)
- Problem of video streaming: 1B users; heterogeneity; major consumer of internet bandwidth
    - Solution: distributed, application-level infrastructure
- Video coding: 
    - spatial coding (within image) & temporal coding (from one to next)
    - CBR vs VBR
- DASH: Dynamic adaptive streaming over HTTP
    - Server: divide video into multiple chunks (each stored in different rates i.e. VBR) + manifest file (provides URLs for different chunks)
    - clients can choose different coding rates at different points in time
        - determines when, where, and encoding rate to request chunk

### CDN
- Problem: how to stream content to a lot of users
    - Solution: store / serve multiple copies of videos at multiple geographically distributed sites (CDN)
- Strategy
    - **Enter deep**: push CDN servers to access networks (1000+ locations)
    - **Bring home**: small number of large clusters near access networks (10's, more latency)
- Updating content: Pull based approach vs. Push based approach
- **OTT** (over the top) can run even in congested network (choose another CDN copy)
- Distributed: no single point of failure

## 2.7 Socket Programming
**Socket** is a door between application process and end-end-transport protocol

### UDP
no handshaking   
need to attach server address and IP to each packet

### TCP
- have 2 sockets: 
    - original socket: handshaking process
    - connection socket: socket after connection is established

## 3.1 Transport-layer services
Provides logical communication between **processes** on different hosts (run in end systems)  
**Network layer** provides logical communication between hosts.  
**Why logical?** successful communication depends on other layers  
**Sender side** breaks app messages into segments & pass to network layer   
**Receiver side** reassembles segments into messages & pass to app layer  

### Protocols
TCP (reliable, in-order delivery, flow & congestion control, connection setup)   
UDP

## 3.2 Multiplexing and demultiplexing
- **Multiplexing** sender handles data from multiple sockets and adds transport header
- **Demultiplexing** receiver delivers received segments to correct socket based on IP & port
    - Each IP datagram from network layer has source IP, dest IP, and 1 transport-layer segment
    - Each segment contains source port number & dest port number, other headers, and payload
    - Connectionless (e.g. UDP)
        - 2 tuple: destination IP & port
        - each socket is for a single process and is shared with multiple clients (does not care about source IP / port)
    - Connection-oriented (TCP): receiver uses all 4 values to direct segment to socket
        - servers have different sockets for each connecting clients of a single process

## 3.3 UDP
- Connectionless, 'best effort' service
- Examples: DNS, streaming apps
- Why UDP
    - no connection delay
    - small header size (8 for UDP vs 20 for TCP)
    - no congestion control (as fast as possible)
- Segment header: source port num, dest port num, length, checksum
- Checksum calculation

## 3.4 Reliable Data Transfer (in transport layer)
Complexity of rdt depends on characteristics of unreliable channel

### Core methods (in the order of data flow)
rdt_send (calls udt_send)  
udt_send   
rdt_rcv (calls deliver_data)  
deliver_data   

### Development of rdt
- 1.0 over a reliable channel
- 2.0 with bit errors
    - detection: checksum
    - notification:
        - **acknowledgements (ACK)**
        - **negative acknowledgements (NAK)** sender would re-transmit
    - flaw: ACK/NAK corrupted
- 2.1 handles above flaw by introducing **sequence number**
    - since **stop-and-wait**, so we only need 0 and 1 seq number to detect duplicate
- 2.2 remove NAK
    - receiver includes seq number with ACK
    - receiver sends the last successful ack'ed seq number each time
- 3.0 bit errors and loss
    - sender waits a period of time for ACK; re-transmit if not received
    - $$ U_{sender} = \frac{L/R}{RTT + L/R} $$

### Pipeline (all of above are **stop-and-wait**: sender sends one packet, then waits for receiver response)
- GBN
    - only needs timer for oldest unacked packet
        - timeout: retransmit all unacked packets
    - k-bit seq number: window size N has to be smaller than $$ 2^k $$
    - send_base, nextseqnum
    - receiver
        - sends cumulative ack of the highest seq number (all ACK's are in order)
        - only tracks next sequence number expecting
        - discards any out of order packets
- Selective repeat
    - receiver
        - sends individual ack
            - maintain timer for each un'ack packets
        - store out-of-order packets in a buffer
     - window size should be less than or equal to $$ 2^(k-1) $$, where k is the number of bits for sequence number
     - send_base & rcv_base
     - dlemma: duplicate data accepted as new if sequence number space is not enough

## 3.5 TCP
Overview: point-to-point, reliable, in-order, flow & congestion control, full-duplex, connection oriented

### Segment structure
- 32 bits Sequence number in TCP: byte stream number of first byte in segment's data
- 32 bits Acknowledgement number: cumulative ack, send the seq number of next expected byte (GBN)
- 16 bits **receive window**: flow control
- RTT vs timeout
    - Estimated RTT: $$ Estimated = (1 - \alpha) * Estimated + \alpha * sampleRTT, \alpha $$ is a hyperparameter, usually set to 0.125
    - RTT Deviation (variance): $$ dev = (1-\beta)*dev + \beta * |Sample - Estimated|, \beta $$ is a hyperparameter, usually set to 0.25
    - Timeout interval $$ = Estimated + 4 * dev $$ (safety margin)

### Reliable data transfer
- RDT in TCP looks like a mixture of GBN and selective repeat
    - looks like GBN: send cumulative ACKs
    - looks like selective repeat: store out-of-order segments
- Sender
- Receiver scenarios
    1. in-order, no pending: wait for 500ms then ack
    2. in-order, has pending acks from (1): send ack
    3. out-of-roder
    4. fill part of gap from lower end: send ack
- fast re-transmit: re-transmit the un'acked segment with smallest seq num if 3 duplicate ACKs (total 4 ACKs) for same data is received

### Flow control (Ensure sender won't overflow receiver's buffer)
- Receiver buffer size (default 4096 bytes) = rwnd (free space) + buffered data
- Receiver tells the free buffer space through rwnd value in TCP header, and sender maintains that knowledge
- Sender limits num of unacked & in-transit data (i.e. last byte sent - last byte ack'ed) to receiver's **rwnd** value

### Connection management
- agree on connection parameters: seq #, receiveBuffer size of client & server
- 2-way handshake failures: half open connection due to delay, re-transmit app data due to message loss
- 3-way handshake (ensure both client & server are alive)
    - Upon receiving SYN, server returns a SYNACK with an initial seq num that is a hash of the IP addresses and port numbers in the SYN segment, and a secret number only known to the server
        - why using special initial seq number? defend against SYN FLOOD attacks
        - usually server adds a time stamp in initial seq number with TTL to prevent attackers from using a large range of numbers
- Teardown
    - Wait for a period after teardown: let TCP client resends final acknowledgment in case the ACK is lost

## 3.6 Principles of congestion control
- End-end congestion control e.g. TCP
- Network-assisted congestion control

## 3.7 TCP congestion control
- Congestion window (cwnd; managed by sender)
    - additive increase (that period is called congestion avoidance)
    - multiplicative decrease
    - number of un'acked sent packets is bounded by congestion window
- TCP sending rate: $$ rate = \frac{cwnd}{RTT} $$ 
- Cwnd size: 1 -> exponentially increase till threshold, then additive increase
    - upon loss (3 duplicate acks): threshold -> half of current cwnd. reno -> cut cwnd by half + 3; tahoe -> set cwnd to 1, exponential growth until reaching threshold
    - upon timeout: threshold -> half of current cwnd. both reno and tahoe set cwnd to 1, exponential growth
- TCP avg throughput: $$ \frac{\frac{3}{4}W}{RTT} $$, where W is max window size before loss occurs
- TCP throughput with segment loss probability L: $$ \frac{1.22*MSS}{RTT*\sqrt{L}} $$
- TCP fairness
    - achieved by congestion window
    - use UDP if don't want to be constrained
    - could open parallel connections to get more bandwidth
- Explicit Congestion Notification
    1. router sets 2 bits in ToS field if there is congestion from sender to receiver
    2. receiver uses ECE (explicit congestion echo) bit to notify the sender about congestion
    3. sender sends CWR (congestion window reduced) back to receiver to acknowledge cut in transmission rate

## 4.1 Overview of Network layer
- Provided service: transport segments among hosts
- protocol in every host / router
- Core functions: forwarding, routing
- Layers
    - Data plane (per-router function; forwarding)
    - Control plane (network-wide logic; routing)
        - **Traditional routing alg** routing alg in every router in the network
        - **SDN** a centralized remote controller interacts with local control agents
- Network service model
    - Network layer does not provide any guarantees on delivery or maximum delay

## 4.2 Router
- Input port
    - Line termination (physical layer)
    - Link layer protocol (data link layer)
    - Look up, forwarding, queueing 
        - **Decentralized switching** why? complete processing at 'line speed' 
            - **Destination based forwarding** based on ip address (look up forward table)
                - Longest prefix matching
                    - Achieved by TCAM (Ternary content addressable memories): retrieve address in constant time regardless of time size
            - **Generalized forwarding** based on any set of header field values (look up flow table)
            - Forward tables & flow tables are computed by control plane
    - Switching fabrics
        - switching rate
        - 3 types: memory, bus, crossbar
            - crossbar can send all packets in parallel if go to different output ports
        - Input queueing
            - Head-of-the-Line blocking
- Output port
    - Datagram buffer
        - scheduling discipline
            - priority scheduling
                - multiple classes
            - FIFO
                - 3 types of discard policys: tail, priority, random
        - buffer size: $$ \frac{RTT*C}{\sqrt{N}} $$, where C is link capacity, N is number of flows
    - Link layer protocol
    - Line termination

## 4.3 IP
### Datagram format
Header usually 20 bytes i.e. 5 rows (ignore option field; same length as TCP)

### Fragmentation
Fragmentation: fit datagram into MTU of links by dividing one datagram into several ones and reassemble at destination based on ip header offset fields   
Each fragment still has 20 bytes header   
offset in each fragment = (MTU-20)/8 * fragment_index   
flag field in each fragment: if the fragment is full

### IPv4 addressing
- **IP address** 32-bit id for **host, router interface** (network-layer address)
    - **interface** connection between host/router and physical link
    - host usually has 1 or 2 interfaces, whereas routers have multiple
- Subnet
    - IP address: subnet part - first 24 bits
    - can interact within the subnet without intervening router
- CIDR (Classless InterDomain Routing)
    - Previously classful addressing, subnet part: A.B.C; many spaces will be wasted if assign to A or B or C
    - Instead of first 24 bits of subnet part, we can have arbitrary subnet length, specified in x (a.b.c.d/x)
    - prefix: network portion of a CDIRized address
- How does a host get IP address
    - Previously hard-coded by system admin
    - DHCP (dynamic host configuration protocol)
        - Application layer protocol run on top of UDP
        - goal: dynamically get IP address from AS server
        - 3 features: renew, reuse address, support for mobile users
        - transaction phase (broadcast): 4 parts
            - Given there is no IP address assigned to client yet, a transaction ID is used to resolve between multiple simultaneous requests
            - the second DHCP request is broadcast for the case when there are multiple DHCP servers on the network and the client has received multiple DHCP offer responses
        - information provided to new client
            1. allocated IP
            2. address of first-hop router
            3. name & IP of DNS server
            4. network mask (number of bits used as subnet)
- How does a network get subnet? Based on the available space of provider's ISP
    - Hierarchical addressing (filters with different scopes)
- How does an ISP get block of addresses? ICANN


### NAT (Network address translation)
- All datagrams leaving the local network have same single source NAT IP address (one ip address visible to public)
    - store mapping in translation table: WAN side (public) -> LAN side (private)
- Why NAT?
    - only need 1 address from ISP
    - can change inner ip w/t notify outside
    - can change ISP w/t changing inner ip
    - security
- Controversial

### IPv6
- Motivation
    - 32 bit address space full
    - header helps speed processing / forwarding
    - header change to faciltate QoS
- Data format: 40 byte header
    - no fragmentation
    - new fields: 
        - priority
        - flow Label (identify datagrams in same 'flow')
        - next header (identify upper layer protocol for data)
        - hop limit (similar to TTL)
    - 16 bytes source addr & 16 bytes dest addr
    - removed checksum & moved options field to 'next header'
- Not all routers have configured to support IPv6 yet
    - Solution: **tunneling** put IPv6 datagram as payload

## 4.4 Generalized Forward and SDN
Router contains a flow table computed and distributed by a logically centralized router controller

### OpenFlow data plane
- each table entry has a rule; check if incoming datagrams satisfy a rule -> do corresponding action
- table fields: 
    - pattern / rule (for matching header fields of datagrams)
    - actions (e.g. forward, drop)
    - priority
    - counters (# of packets, bytes)

## 5.1 Network layer control plane overview
2 approaches to structure control plane: per-router, SDN (determines how forward table is computed)

## 5.2 Routing Protocol
Goal: determine the least cost, fastest, least congested path through network of routers between sending host and receiving host

### Abstraction: Cost
- Cost of link could be 1, inversely related to bandwidth, or inversely related to congestion
- Routing alg classification
    - global / decentralized information
        - global: link state (know complete topology)
        - decentralized: distance vector (only know link costs to neighbours)
    - static / dynamic (e.g. routes update in response to link cost changes)

### Link state
- Knowledge is transferred by 'link state broadcast' (all nodes have same info)
- Dijkstra's alg
    - computes least cost paths from source to all other nodes
    - idea: adds the node w with min distance from set and update costs (distance to source) for all neighbours v of w
        - $$ D(v) = min(D(v), D(w) + c(w,v)) $$
    - best runtime O(nlogn)
- oscillations: real time cost may vary depends on congestion
- Problems: may advertise incorrect link cost

### Distance vector
- Bellman-Ford equation (dynamic programming)
    - $$ d_x(y) = min(c(x, v) + d_v(y)) $$, where $$ d_x(y) $$ is the least cost from x to y, c(x, v) is the cost from x to one of its neighbours v, min is taken over all neighbours v of x
- In Distance vector alg., $$ D_x(y) $$ is the estimate cost from x to y, x maintains **distance vectors (DV)** i.e. estimated distances from x to all nodes
    - x also knows cost to each neighbour and each neighbour's distance vectors
    - Idea of alg.: upon receiving updates from neighbours or detected link cost change, update the node's DVs using BF equation. If any DV has changed, notifies neighbours
- Problems: 
    - count to infinity: 2 neighbours update and notify each other back and forth
        - solution: poisoned reverse - if Z -> Y -> X, then Z tells Y the distance of Z and X is infinite (so Y won't route to X via Z)
            - Poisoned reverse does not solve the count to infinity problem for routing loops involving three or more nodes
    - advertise incorrect path cost

## 5.3 Intra-AS routing
- In practice, need to consider scalability & administrative autonomy
- Structures in reality
    - Autonomous systems (Domain): aggregate routers into regions
        - Gateway routers
        - Intra-AS routing (within AS)
        - Inter-AS routing (among AS'es)
        - Forward table determined by both routing alg.
- Intra-AS routing (aka. interior gateway routing)
    - To transfer packets to correct gateway router, needs help from intra-AS routing to get reachability information
    - Common protocols: RIP, OSPF, IGRP
    - OSPF (Open Shortest Path First)
        - link state alg.
        - OSPF is a link-layer protocol, advertise messages directly over IP
        - features
            - security
            - multiple same-cost paths allowed
            - multiple cost metrics for different TOS
        - Hierarchical OSPF
            - each nodes runs its own link state routing alg. (has detailed area topology)
            - **area boarder routers** advertise distances to other areas
            - **backbone area** route traffic between the other areas in the AS
            - **boundary routers** connect to other AS'es

## 5.4 Inter-AS routing: BGP
BGP: Border Gateway Protocol (used by all inter-AS routing)   
**eBGP** get reachability info from neighbour AS   
**iBGP** propagate info to internal routers   
Note: BGP is an app-layer protocol; it opens TCP sessions with other peers
- BGP-enabled routers implement the complete stack to support BGP messages over TCP in the control plane

### Basics
- Advertise paths (reachability to other AS'es) to different destination network prefixes
    - Path attributes:
        - **AS-PATH** list of ASes (detect looping)
        - **NEXT-HOP** specify the internal-AS router to next-hop AS (construct forwarding table)
- **Policy-based routing** uses import policy to accept / decline a path

### Messages
- exchanged between peers over TCP connection
- types
    - open: open TCP connection
    - update: advertises new path
    - keepalive
    - notification: report error / close connection
- forwarding table entry: destination -> local interface (link to first hop router)

### Route Selection
- Factors (priority from high to low)
    - policy decision
        - dual-homed: attached to 2 networks
    - shortest AS-PATH
    - closest NEXT-HOP router (choose local gateway with least intra-domain cost)

### Why different intra, inter-AS routing
- Policy or not
- Scale: hierarchical routing saves table size
- Performance (related to policy as well)

## 5.5 SDN control plane
- Logically centralized control plane (typically running on servers in a datacenter)
    - Motivations
        - easy network management
        - easy router programming: compute tables centrally then distribute
        - open implementation of control plane

### Features
- generalized forwarding
- decoupling of data & control plane
- control plane functions external to data-plane switches
- programmable control apps

### Perspective
- SDN-controlled switches 
    - implemented generalized forwarding in hardware
    - API for table-based switch control
- SDN controller
    - maintain network state info
    - distributed
    - layers
        - interface layer to network control apps e.g. network graph, RESTful API
        - network-wide state management layer: distributed db for managing state of network links
        - communication layer to switches e.g. OpenFlow, SNMP
- Network-control apps
    - implement control functions using API provided by controller (make routing decision)

## 5.6 ICMP (Internet Control Message Protocol)
- Used by hosts & routers to communicate network-level information
    - error report
    - echo request / response
- messages carried in IP datagrams

### Traceroute
- source send sets of UDP segments each set has TTL equal to set number (1, 2, ... n)
- when nth set reaches nth router, router will send back TTL expire ICMP
- stop upon reaching destinationi and receiver sends 'port unreachable' message


## 6.1 Link layer introduction
Datagrams might be transferred by different link layer protocols over different links   
MAC address in frame header to identify source & dest - 48 bits  
Services   
1. Framing    
2. Reliable data transfer (would like to resolve error locally instead of relying on TCP rdt)   
3. Error detection and correction   

### Location
- In router: input ports & output ports
- In host: network interface card (adaptor) or on a chip
    - attaches into host's system buses


## 6.2 Multiple access protocols
determines how nodes share a single shared broadcast channel upon sending / receiving packets

### protocols taxonomy
- **channel partitioning** divide and reserve space for each node to use
    - e.g. TDMA: time division multiple access
        - n-slot frame repeat, where n is max number of nodes can share at same time
        - if number of nodes < n, then some spaces will be wasted
    - e.g. FDMA: frequency division multiple access
    - inefficient in low-load
- **random access** allow collisions
    - protocol specifies how to detect and recover from collisions
    - e.g. CSMA (carrier sense multiple access)
        - listen to channel: busy - wait; free - transfer
        - collisions can still occur due to propagation delay (when both senders send together)
        - upon collision, entire packet transmission time wasted
        - CSMA/CD
            - collisions detected within short time
            - colliding transmissions will be aborted to reduce wastage, detector sends a jam signal to all other adapters (e.g., in the Ethernet segment) to inform the other adapters of the collision and that they must not transmit
            - easy to detect in wired LANs; difficult to detect in wireless LANs
            - **binary backoff** after m-th collision, choose k between 0 and $$ 2^m - 1 $$, wait for $$\frac{k * 512 bits}{R (bits/s)} $$ time, then try re-send
                - why varied time? too short - more transmissions than range; too long - unnecessary wait
                - 512 bits: minimum frame size (too short - cannot detect collision)
            - efficiency: $$ \frac{1}{1 + 5*t_{prop}/t_{trans}}$$, where $$ t_{prop} $$ is max prop delay between 2 nodes, $$ t_{trans} $$ is time to transmit max-szie frame
        - CSMA/CA: collision avoidance
            - sense before transmitting
            - used in 802.11, which is difficult to sense collisions & receive sense collision signal
    - inefficient in high-load (collision overhead)
- 'taking turns'
    - polling: master node invites slave nodes to transmit in turn
        - concerns: overhead, latency, single point of failure
    - token passing: control token passed from one node to next sequentially


## 6.3 LANs (local area network)
Group of computers and associated devices that share a common communications line or wireless link to a server  

### addressing, ARP
- MAC address: 48 its burned in NIC ROM (static)
    - used ‘locally” to get frame from one interface to another physically-connected interface
    - uniqueness is ensured by IEEE: manufacturer buys portion of MAC address space from IEEE
    - one MAC address assoicated with each interface
- ARP: address resolution protocol
    - function: fetch MAC address based on IP
        - A broadcasts ARP query, B replies with its MAC address
    - each IP node has ARP table that stores mapping between IP and MAC

### Ethernet
- 'dominant' wired LAN technology; cheap; not slow
- physical topology
    - bus: may have collisions
    - star: nodes do not collide
- frame structure
    - preamble: synchronize receiver, sender clock rates
    - source, destination address: 6 bytes MAC address
    - type: higher layer protocol
    - CRC: cyclic redundancy check - error detection
    - payload: min size - 512; max size - 1500
- features
    - connectionless between 2 NIC interfaces
    - unreliable
    - MAC protocol: CSMA/CD with binary backoff
- Ethernet standard
    - e.g. 100BASE-T4: 100 Mbps, Baseband ethernet, twisted pair (copper), 4 twists

### switches
- ethernet protocol used on each incoming link
- features: 
    - buffer
    - full duplex
    - plug-and-play; self-learning: add location of sender to **switch table** upon receiving the sending packet
        - switch table entry: MAC address, Interface of the router's port connecting to the MAC address, TTL
        - dest. MAC address in switch table ? forward to the output interface : flood
- switch vs router

## 6.4 Data center networking
- Load balancer: app-layer routing  
    - hides data center internals from client
- Blade: hosts in data centers; which are stacked together in racks
- Routers
    - boarder: connect data center network to public internet (specifically access router)
    - access: connect with tier-1 switches
- Switches
    - tier 1: connect with tier-2 switches & load balancer
    - tier 2: connect with TOR switches
    - TOR: interconnects the hosts in the rac with each other and with other switches in the data center


## 6.5 Send request to www.google.com
1. DHCP: get own IP, IP for first hop router, and IP for DNS server
2. ARP: get MAC address of first hop router based on IP address
3. DNS query: get IP address of google.com
4. Open TCP socket to web server
5. send HTTP request 

## Top-10 network challenges
1. Reliable data transfer
2. Principles of congestion control
3. routing
